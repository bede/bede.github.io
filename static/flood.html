<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Head content remains the same -->
    <title>ðŸš¦ Muchelney area flood status</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        /* General Styles */
       body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: white; /* Match plot background */
            color: #333;
        }

        h1 {
            font-size: 1.6rem;
            font-weight: 600;
            margin: 5px 0px 4px 15px;
            color: #1f77b4;
        }

        h2 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 6px 0px 3px 15px;
            color: #1f77b4;
        }

        p, ul, li {
            margin: 0;
            padding: 0;
        }

        p {
            font-size: 1rem;
            margin: 2px 15px;
        }

        ul {
            margin: 0 15px 10px 15px;
            padding: 0;
            list-style: none;
        }

        ul li {
            font-size: 1rem;
            margin-bottom: 5px;
        }

        a {
            color: #1d70b8;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .circle {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .circle.green {
            background-color: #4CAF50;
        }

        .circle.amber {
            background-color: #FFC107;
        }

        .circle.red {
            background-color: #F44336;
        }

        #tab-contents {
            margin: 0;
        }

        .tab-container {
            margin: 10px 15px;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #ccc;
            margin: 0 0px;
        }

        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f5f5f5;
            border: none;
            outline: none;
            font-size: 1rem;
            font-weight: 600;
            color: #333;
        }

        .tab-button.active {
            background-color: #fff;
            border-bottom: 2px solid #1f77b4;
            color: #1f77b4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .chart {
            width: 100%;
            height: 280px;
            margin: 0;
            padding: 0;
        }

        #map {
            width: 100%;
            height: 240px;
            margin: 0;
            padding: 0;
        }

        footer {
            font-size: 0.9rem;
            margin: 20px 15px;
            text-align: center;
            color: #555;
        }
    </style>
    <script>
        // PostHog script (unchanged)
    </script>
</head>
<body>
    <h1>Muchelney area road status</h1>
    <ul id="road-status-list">
        <!-- Road statuses will be inserted here -->
    </ul>

    <!-- Tabs for charts -->
    <div class="tab-container">
        <div class="tab-buttons" id="tab-buttons">
            <!-- Tab buttons will be inserted here -->
        </div>
        <div id="tab-contents">
            <!-- Tab contents (charts) will be inserted here -->
        </div>
    </div>

    <!-- Map -->
    <div id="map"></div>

    <footer>
        Feedback: <a href="mailto:b@bede.im">b@bede.im</a> | 
        <a href="https://check-for-flooding.service.gov.uk/station/3379">data</a> | <a href="https://check-for-flooding.service.gov.uk/target-area/112WAFYPM">flood alert</a> | <a href="https://www.somerset.gov.uk/roads-travel-and-parking/emergency-road-closure-gates/">emergency gate status</a>
    </footer>

    <script>
        const SOURCES = [
            {
                name: "Long Load Main Drain",
                url: "https://check-for-flooding.service.gov.uk/station-csv/3379",
                elementId: "long-load",
                datumOffset: 5,
                roads: [
                    {
                        name: "Langport to Muchelney",
                        amberThreshold: 7.30,
                        link: "https://www.somerset.gov.uk/roads-travel-and-parking/emergency-road-closure-gates/",
                        markerPosition: [51.0266797, -2.8174208]
                    },
                    {
                        name: "Muchelney to Long Load",
                        amberThreshold: 7.86,
                        link: "",
                        markerPosition: [51.009468, -2.793615]
                    },
                    {
                        name: "Muchelney to Thorney",
                        amberThreshold: 7.93,
                        link: "",
                        markerPosition: [51.0132813, -2.8149388]
                    }
                ],
                thresholds: [
                    { name: "Property flooding", value: 8.35 },
                    { name: "Top of normal range", value: 7.06 }
                ]
            },
            {
                name: "West Moor Drain",
                url: "https://check-for-flooding.service.gov.uk/station-csv/3381",
                elementId: "west-moor",
                datumOffset: 5.185,
                roads: [
                    {
                        name: "Hambridge to Burrow",
                        amberThreshold: 7.65,
                        link: "",
                        markerPosition: [51.0055, -2.8744]
                    }
                ],
                thresholds: [
                    { name: "Top of normal range", value: 6.645 }
                ]
            }
        ];

        // Colours
        const COLORS = {
            green: "#4CAF50",
            amber: "#FFC107",
            red: "#F44336"
        };

        // Global object to store latest readings
        const latestReadings = {};

        // Fetch data, create charts, and update road statuses
        async function fetchAndProcessData() {
            try {
                // Fetch data for all sources
                await Promise.all(SOURCES.map(async (source) => {
                    const parsedData = await fetchData(source);
                    const latestReading = parsedData[parsedData.length - 1];
                    latestReadings[source.elementId] = latestReading;
                    renderChart(parsedData, source);
                }));

                // Update road statuses
                updateRoadStatuses();

                // Render map
                renderMap();

                // Initialize tabs
                initializeTabs();

                // Resize the chart in the default active tab
                const defaultChartDiv = document.querySelector('.tab-content.active');
                if (defaultChartDiv) {
                    Plotly.Plots.resize(defaultChartDiv);
                }

            } catch (error) {
                console.error("Error:", error);
                alert("Failed to fetch and process data.");
            }
        }

        // Fetch data from cache or API
        async function fetchData(source) {
            const cacheKey = `waterLevelsCSV_${source.elementId}`;
            const cachedCSV = localStorage.getItem(cacheKey);
            const cachedTimestamp = localStorage.getItem(`${cacheKey}_timestamp`);
            const now = new Date().getTime();

            if (cachedCSV && cachedTimestamp && now - cachedTimestamp < 15 * 60 * 1000) {
                console.log(`Using cached data for ${source.name}`);
                return parseCSV(cachedCSV, source);
            }

            console.log(`Fetching new data for ${source.name}`);
            const response = await fetch(source.url);
            if (!response.ok) throw new Error("Failed to fetch data");
            const csvData = await response.text();

            localStorage.setItem(cacheKey, csvData);
            localStorage.setItem(`${cacheKey}_timestamp`, now.toString());

            return parseCSV(csvData, source);
        }

        // Parse CSV data
        function parseCSV(csvData, source) {
            return csvData
                .trim()
                .split("\n")
                .slice(1)
                .map((row) => {
                    const [timestamp, height] = row.split(",");
                    return { timestamp, height: parseFloat(height) + source.datumOffset };
                });
        }

        // Update road statuses
        function updateRoadStatuses() {
            const roadStatusList = document.getElementById('road-status-list');
            roadStatusList.innerHTML = ''; // Clear existing list

            SOURCES.forEach(source => {
                const sourceReading = latestReadings[source.elementId];
                if (sourceReading) {
                    source.roads.forEach(road => {
                        const status = determineStatus(sourceReading.height, road.amberThreshold);

                        const li = document.createElement('li');

                        const circle = document.createElement('span');
                        circle.classList.add('circle', status.color);
                        li.appendChild(circle);

                        const text = document.createElement('span');
                        if (road.link) {
                            text.innerHTML = `<a href="${road.link}">${road.name}</a>: <strong>${status.message}</strong>`;
                        } else {
                            text.innerHTML = `${road.name}: <strong>${status.message}</strong>`;
                        }
                        li.appendChild(text);

                        roadStatusList.appendChild(li);
                    });
                }
            });
        }

        // Determine road status
        function determineStatus(height, amberThreshold) {
            const redThreshold = amberThreshold + 0.30; // Red threshold is 30cm above amber
            if (height >= redThreshold) {
                const diff = ((height - amberThreshold) * 100).toFixed(0); // Difference in cm
                return { color: 'red', message: `deep flood (${diff}cm)` };
            } else if (height >= amberThreshold) {
                const diff = ((height - amberThreshold) * 100).toFixed(0); // Difference in cm
                return { color: 'amber', message: `flood (${diff}cm)` };
            } else {
                return { color: 'green', message: 'clear' };
            }
        }

        // Render the chart
        function renderChart(parsedData, source) {
            const timestamps = parsedData.map((d) => d.timestamp);
            const heights = parsedData.map((d) => d.height);

            // Create threshold lines and labels for roads and additional thresholds
            const thresholds = [
                ...source.roads.map((road) => ({
                    name: road.name,
                    value: road.amberThreshold
                })),
                ...(source.thresholds || []) // Include additional thresholds if any
            ];

            const thresholdLines = thresholds.map((threshold) => ({
                x: [timestamps[0], timestamps[timestamps.length - 1]],
                y: [threshold.value, threshold.value],
                mode: "lines",
                name: threshold.name,
                line: { dash: "dot", width: 1, color: "black" },
                hoverinfo: "none"
            }));

            const thresholdLabels = thresholds.map((threshold) => ({
                x: [timestamps[0]],
                y: [threshold.value],
                mode: "text",
                text: [`${threshold.name} (${threshold.value.toFixed(2)}m)`],
                textposition: "top right",
                textfont: { family: "Inter, sans-serif", size: 10, color: "black" },
                showlegend: false,
                hoverinfo: "none"
            }));

            const waterLevelTrace = {
                x: timestamps,
                y: heights,
                mode: "lines",
                name: "",
                line: { color: "#1f77b4", width: 3 },
                fill: "tozeroy",
                fillcolor: "rgba(31, 118, 180, 0.1)"
            };

            // Add latest reading marker and annotation
            const latestReading = parsedData[parsedData.length - 1];

            // Format the timestamp for the annotation
            const latestDate = new Date(latestReading.timestamp);
            const hours = latestDate.getUTCHours().toString().padStart(2, '0');
            const minutes = latestDate.getUTCMinutes().toString().padStart(2, '0');
            const timeString = `${hours}:${minutes} UTC`;

            const latestPointTrace = {
                x: [latestReading.timestamp],
                y: [latestReading.height],
                mode: "markers",
                marker: { color: "black", size: 8 },
                name: "Latest Reading",
                hoverinfo: "none"
            };

            const latestReadingAnnotation = {
                x: latestReading.timestamp,
                y: latestReading.height,
                xref: 'x',
                yref: 'y',
                text: `${latestReading.height.toFixed(2)}m (${timeString})`,
                showarrow: true,
                arrowhead: 6,
                ax: -28,
                ay: -28,
                font: { family: "Inter, sans-serif", size: 12, color: "black" },
                bordercolor: "black",
                borderwidth: 1,
                bgcolor: "#fff",
                opacity: 1.0
            };

            const layout = {
                xaxis: {
                    tickformat: "%Y-%m-%d",
                    showgrid: true,
                    title: "",
                    tickfont: { 
                        family: "Inter, sans-serif", 
                        size: 11
                    },
                    range: [timestamps[0], timestamps[timestamps.length - 1]]
                },
                yaxis: {
                    showgrid: true,
                    tickformat: ".1f",
                    ticksuffix: "m",
                    range: [7, 8.5],
                    tickfont: { family: "Inter, sans-serif", size: 11 },
                    side: "right"
                },
                annotations: [latestReadingAnnotation],
                showlegend: false,
                font: { family: "Inter, sans-serif" },
                margin: { t: 12, b: 30, l: 0, r: 28 },
                autosize: true,
                dragmode: false
            };

            // Create chart container
            const tabContents = document.getElementById('tab-contents');
            const chartDiv = document.createElement('div');
            chartDiv.id = `chart-${source.elementId}`;
            chartDiv.classList.add('chart', 'tab-content');
            tabContents.appendChild(chartDiv);

            Plotly.newPlot(`chart-${source.elementId}`, [waterLevelTrace, latestPointTrace, ...thresholdLines, ...thresholdLabels], layout, {
                responsive: true,
                displayModeBar: false,
                scrollZoom: false
            });

            // Create tab button
            const tabButtons = document.getElementById('tab-buttons');
            const tabButton = document.createElement('button');
            tabButton.classList.add('tab-button');
            tabButton.textContent = source.name;
            tabButton.dataset.target = `chart-${source.elementId}`;
            tabButtons.appendChild(tabButton);
        }

        // Initialize tabs
        function initializeTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            // Set default active tab
            tabButtons[0].classList.add('active');
            tabContents[0].classList.add('active');
            // Ensure the chart in the active tab is resized correctly
            Plotly.Plots.resize(tabContents[0]);

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons and contents
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });

                    // Add active class to the clicked button and corresponding content
                    button.classList.add('active');
                    const targetContent = document.getElementById(button.dataset.target);
                    targetContent.classList.add('active');
                    targetContent.style.display = 'block';

                    // Resize Plotly chart in the active tab
                    Plotly.Plots.resize(targetContent);
                });
            });
        }

        // Render the map
        function renderMap() {
            const map = L.map("map").setView([51.016, -2.82], 12);

            // Add OpenStreetMap tiles
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution:
                    "&copy; <a href='https://www.openstreetmap.org/copyright'>OpenStreetMap</a> contributors"
            }).addTo(map);

            // Add markers for each road
            SOURCES.forEach(source => {
                const sourceReading = latestReadings[source.elementId];
                if (sourceReading) {
                    source.roads.forEach(road => {
                        if (road.markerPosition) {
                            const status = determineStatus(sourceReading.height, road.amberThreshold);
                            addMarker(
                                map,
                                road.markerPosition,
                                road.name,
                                source.name,
                                status,
                                determineMarkerColor(sourceReading.height, road.amberThreshold)
                            );
                        }
                    });
                }
            });
        }

        // Add a marker to the map
        function addMarker(map, position, roadName, sourceName, status, color) {
            const popupContent = `
                <strong>${roadName}</strong><br>
                Tracks ${sourceName} level<br>
                Status: <strong>${status.message}</strong>
            `;
            L.marker(position, {
                icon: L.divIcon({
                    className: "custom-icon",
                    html: `<div style="background-color: ${color}; width: 20px; height: 20px; border-radius: 50%;"></div>`
                })
            })
                .addTo(map)
                .bindPopup(popupContent);
        }

        // Determine marker color
        function determineMarkerColor(height, amberThreshold) {
            const redThreshold = amberThreshold + 0.30;
            if (height >= redThreshold) return COLORS.red;
            if (height >= amberThreshold) return COLORS.amber;
            return COLORS.green;
        }

        // Fetch and process data on page load
        window.onload = fetchAndProcessData;
    </script>
</body>
</html>
